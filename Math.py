import psycopg2
import random
from random import randint
from tkinter import *
from tkinter import Tk
import tkinter.scrolledtext as scrolledtext
import logging
import datetime


def generated_numbers_check(v_list):
    for v in v_list:
        if ((type(v) != int) and (type(v) != float)):
            raise Exception("Invalid type was generated by the number generator method")

    for v in v_list:
        if (v>=0 and v<1):
            v = 1
            print("Number from the collection that was less than 1 has been changed to 1 in order to avoid "
                  "ZeroDivisionError")

"""Instance of tkinter-based UI - class definition"""
class TkUi:
    root = Tk()
    root.title("Ui")
    txt = scrolledtext.ScrolledText(root, height=8, undo=True, font=("Verdana", "16"),
                                    relief='solid', highlightthickness=1,
                                    highlightbackground="Black")
    txt.configure(padx=190, bg="white", spacing1=2, spacing2=3, spacing3=2, wrap=WORD, state="disabled")
    txt.pack(expand=True, fill='both', pady=12)
    root.configure(background="LightSkyBlue2")

    @classmethod
    def centerWindow(cls, w=300, h=200):
        ws = cls.root.winfo_screenwidth()
        hs = cls.root.winfo_screenheight()
        x = (ws / 2) - (w / 2)
        y = (hs / 2) - (h / 2) - 35
        cls.root.geometry('%dx%d+%d+%d' % (w, h, x, y))

    # root.tk.call('wm', 'iconphoto', root._w, tk.PhotoImage(file='images/iconchat.ico'))


"""Class containing mathematic operations/functions based on randomly generated collection of numbers"""


class MathOps:

    def __init__(self, numbers):
        self.numbers = numbers

    @staticmethod
    def numbers_generator_int(quantity):
        while quantity > 0:
            yield randint(1, 10)
            quantity = quantity - 1

    @staticmethod
    def numbers_generator_float(quantity):
        while quantity > 0:
            yield random.uniform(1.0, 10.0)
            quantity = quantity - 1

    '''List preferably'''
    @staticmethod
    def quadratic_function_constructor(numbers=(1, 1, 1)):
        return lambda x: numbers[0] * x ** 2 + numbers[1] * x + numbers[2]

    '''List preferably'''
    @staticmethod
    def exponential(base=1, exponent=1):
        base = int(base)
        exponent = int(exponent)
        return base ** exponent

    '''List preferably'''
    @staticmethod
    def factorial(number=1):
        number = int(number)
        result = 1
        for v in range(1, number+1):
            result = result * v
        return result

    '''Square root as default'''
    @staticmethod
    def root_function(root_degree=2.0, under_root=1.0):
        root_degree = int(root_degree)
        under_root = int(under_root)
        return root_degree**(1/under_root)

    '''Basic operations'''
    @staticmethod
    def sum(numbers=(1, 1, 1)):
        result = 0
        for v in numbers:
            result = result + v
        return result

'''
Adding optional PostgreSQL based database that stores almost the same data that is saved into log files.
I used pgAdmin4 to create database with table "Results" that has 3 columns:
- Parameters - numbers passed to function;
- Function_used - name of function that has been used;
- Function_result - output of the function
If different names are used for columns or table, then respective names in the INSERT INTO query must be used/changed
 and also in giving parameters in cursor.execute().
'''

def db_save(parameters, function_name, function_result):
    connection = psycopg2.connect(dbname="MathOps_results", user="postgres", password="Samogone")
    c = connection.cursor()
    c.execute(
        "INSERT INTO \"Results\" (\"Parameters\",\"Function_used\", \"Function_result\") VALUES(%s, %s, %s);",
        (parameters, function_name, function_result)
    )
    connection.commit()
    c.close()
    connection.close()

"""Putting MathOps operations results into the UI and logging them into file"""
def display_handler(math_instance, ui, f_name, collection, x=1):
    if f_name == MathOps.quadratic_function_constructor.__qualname__:
        output = math_instance.quadratic_function_constructor(collection)
        output = output(x)

    if f_name == MathOps.exponential.__qualname__:
        collection = collection[:2]
        output = math_instance.exponential(collection[0], collection[1])

    if f_name == MathOps.root_function.__qualname__:
        collection = collection[:2]
        output = math_instance.root_function(collection[0], collection[1])

    if f_name == MathOps.sum.__qualname__:
        output = math_instance.sum(collection)

    if f_name == MathOps.factorial.__qualname__:
        collection = collection[0:1]
        output = math_instance.factorial(collection[0])

    ui.txt.configure(state="normal")
    ui.txt.insert(INSERT, f'\nResult of the function {f_name}\nfor the collection: {collection}\ngives the '
                          f'result: {output}\n')
    ui.txt.configure(state="disabled")

    """Logging. Using 'n' and 'n_modified' to create log files with next collection of results
     each time the program is executed"""
    LOGGING_FORMAT = "%(levelname)s %(asctime)s - %(message)s"
    n = datetime.datetime.now()
    n_modified = str(n.strftime("%H_%M_%S"))
    logging.basicConfig(filename=f"log{n_modified}",
                        level=logging.DEBUG,
                        format=LOGGING_FORMAT,
                        filemode="w")
    logger = logging.getLogger()
    logging.info(ui.txt.get("1.0", END))
    db_save(collection, f_name, output)

"""Starting UI"""
ui = TkUi()
ui.centerWindow(ui.root.winfo_screenwidth() - 280, ui.root.winfo_screenheight() - 280)

"""Preparing collection of numbers"""
nums_int = MathOps.numbers_generator_int(1200)
nums_float = MathOps.numbers_generator_float(1200)
numbers_collection1 = [next(nums_int), next(nums_int), next(nums_int)]
generated_numbers_check(numbers_collection1)

math1 = MathOps(numbers_collection1)
display_handler(math1, ui, MathOps.quadratic_function_constructor.__qualname__, numbers_collection1, 5)
display_handler(math1, ui, MathOps.exponential.__qualname__, numbers_collection1)
display_handler(math1, ui, MathOps.root_function.__qualname__, numbers_collection1)
display_handler(math1, ui, MathOps.sum.__qualname__, numbers_collection1)
display_handler(math1, ui, MathOps.factorial.__qualname__, numbers_collection1)

numbers_collection2 = list(map(lambda x: x * 2, numbers_collection1))
generated_numbers_check(numbers_collection2)

math2 = MathOps(numbers_collection2)
display_handler(math2, ui, MathOps.quadratic_function_constructor.__qualname__, numbers_collection2, 3)
display_handler(math2, ui, MathOps.exponential.__qualname__, numbers_collection2)
display_handler(math2, ui, MathOps.root_function.__qualname__, numbers_collection2)
display_handler(math2, ui, MathOps.sum.__qualname__, numbers_collection2)
display_handler(math2, ui, MathOps.factorial.__qualname__, numbers_collection2)

numbers_collection3 = [round(next(nums_float), 2), round(next(nums_float), 2), round(next(nums_float), 2)]
generated_numbers_check(numbers_collection3)

math3 = MathOps(numbers_collection3)
display_handler(math3, ui, MathOps.quadratic_function_constructor.__qualname__, numbers_collection3, 3)
display_handler(math3, ui, MathOps.exponential.__qualname__, numbers_collection3)
display_handler(math3, ui, MathOps.root_function.__qualname__, numbers_collection3)
display_handler(math3, ui, MathOps.sum.__qualname__, numbers_collection3)
display_handler(math3, ui, MathOps.factorial.__qualname__, numbers_collection3)

numbers_collection4 = list(map(lambda x: x//6, numbers_collection2))
generated_numbers_check(numbers_collection4)

math4 = MathOps(numbers_collection4)
display_handler(math4, ui, MathOps.quadratic_function_constructor.__qualname__, numbers_collection4)
display_handler(math4, ui, MathOps.exponential.__qualname__, numbers_collection4)
display_handler(math4, ui, MathOps.root_function.__qualname__, numbers_collection4)
display_handler(math4, ui, MathOps.sum.__qualname__, numbers_collection4)
display_handler(math4, ui, MathOps.factorial.__qualname__, numbers_collection4)

ui.root.mainloop()